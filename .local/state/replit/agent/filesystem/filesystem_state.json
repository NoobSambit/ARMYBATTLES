{"file_contents":{"app/signup/page.js":{"content":"'use client';\n\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport Link from 'next/link';\n\nexport default function SignUp() {\n  const router = useRouter();\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: '',\n  });\n  const [error, setError] = useState('');\n  const [loading, setLoading] = useState(false);\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError('');\n    setLoading(true);\n\n    try {\n      const res = await fetch('/api/auth/register', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(formData),\n      });\n\n      const data = await res.json();\n\n      if (!res.ok) {\n        throw new Error(data.error || 'Registration failed');\n      }\n\n      localStorage.setItem('token', data.token);\n      localStorage.setItem('user', JSON.stringify(data.user));\n      router.push('/dashboard');\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div style={{ maxWidth: '400px', margin: '50px auto' }}>\n      <h1>Sign Up</h1>\n      <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n        <input\n          type=\"text\"\n          placeholder=\"Username\"\n          value={formData.username}\n          onChange={(e) => setFormData({ ...formData, username: e.target.value })}\n          required\n          style={{ padding: '10px', fontSize: '16px' }}\n        />\n        <input\n          type=\"email\"\n          placeholder=\"Email\"\n          value={formData.email}\n          onChange={(e) => setFormData({ ...formData, email: e.target.value })}\n          required\n          style={{ padding: '10px', fontSize: '16px' }}\n        />\n        <input\n          type=\"password\"\n          placeholder=\"Password\"\n          value={formData.password}\n          onChange={(e) => setFormData({ ...formData, password: e.target.value })}\n          required\n          minLength={6}\n          style={{ padding: '10px', fontSize: '16px' }}\n        />\n        {error && <p style={{ color: 'red' }}>{error}</p>}\n        <button type=\"submit\" disabled={loading} style={{ padding: '10px', fontSize: '16px', cursor: 'pointer' }}>\n          {loading ? 'Signing up...' : 'Sign Up'}\n        </button>\n      </form>\n      <p style={{ marginTop: '20px' }}>\n        Already have an account? <Link href=\"/login\">Login</Link>\n      </p>\n    </div>\n  );\n}\n","size_bytes":2494},"pages/api/admin/cleanup.js":{"content":"import connectDB from '../../../utils/db';\nimport Battle from '../../../models/Battle';\nimport StreamCount from '../../../models/StreamCount';\nimport { createHandler, withCors, withRateLimit, withAuth } from '../../../lib/middleware';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n\n    const oldBattles = await Battle.find({\n      status: 'ended',\n      endedAt: { $lte: sevenDaysAgo },\n    });\n\n    const battleIds = oldBattles.map(b => b._id);\n\n    const deletedStreamCounts = await StreamCount.deleteMany({\n      battleId: { $in: battleIds },\n    });\n\n    const deletedBattles = await Battle.deleteMany({\n      _id: { $in: battleIds },\n    });\n\n    const orphanedStreamCounts = await StreamCount.deleteMany({\n      battleId: { $nin: await Battle.find().distinct('_id') },\n    });\n\n    logger.info('Cleanup completed', {\n      battlesDeleted: deletedBattles.deletedCount,\n      streamCountsDeleted: deletedStreamCounts.deletedCount,\n      orphanedStreamCountsDeleted: orphanedStreamCounts.deletedCount,\n      adminId: req.userId,\n    });\n\n    res.status(200).json({\n      message: 'Cleanup completed successfully',\n      summary: {\n        battlesDeleted: deletedBattles.deletedCount,\n        streamCountsDeleted: deletedStreamCounts.deletedCount,\n        orphanedStreamCountsDeleted: orphanedStreamCounts.deletedCount,\n      },\n    });\n  } catch (error) {\n    logger.error('Cleanup error', { error: error.message });\n    res.status(500).json({ error: 'Server error during cleanup' });\n  }\n}\n\nexport default createHandler(handler, [\n  withCors,\n  withRateLimit(2, 60000),\n  withAuth({ requireAdmin: true }),\n]);\n","size_bytes":1858},"lib/middleware.js":{"content":"import { getUserFromRequest } from '../utils/auth';\nimport User from '../models/User';\nimport mongoose from 'mongoose';\n\nconst rateLimitStore = new Map();\n\nexport function withRateLimit(limit = 10, windowMs = 60000) {\n  return async (req, res, next) => {\n    const identifier = req.headers['x-forwarded-for'] || req.connection?.remoteAddress || 'unknown';\n    const key = `${identifier}:${req.url}`;\n    \n    const now = Date.now();\n    const record = rateLimitStore.get(key) || { count: 0, resetTime: now + windowMs };\n    \n    if (now > record.resetTime) {\n      record.count = 0;\n      record.resetTime = now + windowMs;\n    }\n    \n    record.count++;\n    rateLimitStore.set(key, record);\n    \n    if (record.count > limit) {\n      return res.status(429).json({ \n        error: 'Too many requests, please try again later',\n        retryAfter: Math.ceil((record.resetTime - now) / 1000),\n      });\n    }\n    \n    next();\n  };\n}\n\nexport function withValidation(schema) {\n  return async (req, res, next) => {\n    try {\n      const validated = schema.parse(req.body);\n      req.validatedBody = validated;\n      next();\n    } catch (error) {\n      if (error.errors) {\n        return res.status(400).json({ \n          error: 'Validation failed', \n          details: error.errors.map(e => ({\n            field: e.path.join('.'),\n            message: e.message,\n          })),\n        });\n      }\n      return res.status(400).json({ error: 'Invalid request data' });\n    }\n  };\n}\n\nexport function withAuth(options = {}) {\n  return async (req, res, next) => {\n    try {\n      const userId = getUserFromRequest(req);\n      \n      if (!userId) {\n        return res.status(401).json({ error: 'Unauthorized - No valid token provided' });\n      }\n      \n      if (!mongoose.Types.ObjectId.isValid(userId)) {\n        return res.status(401).json({ error: 'Unauthorized - Invalid token' });\n      }\n      \n      const user = await User.findById(userId);\n      \n      if (!user) {\n        return res.status(401).json({ error: 'Unauthorized - User not found' });\n      }\n      \n      if (options.requireAdmin && !user.isAdmin) {\n        return res.status(403).json({ error: 'Forbidden - Admin access required' });\n      }\n      \n      req.user = user;\n      req.userId = userId;\n      next();\n    } catch (error) {\n      console.error('Auth middleware error:', error);\n      return res.status(500).json({ error: 'Authentication error' });\n    }\n  };\n}\n\nexport function withCors(req, res, next) {\n  res.setHeader('Access-Control-Allow-Credentials', 'true');\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');\n  res.setHeader(\n    'Access-Control-Allow-Headers',\n    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Authorization'\n  );\n  \n  if (req.method === 'OPTIONS') {\n    res.status(200).end();\n    return;\n  }\n  \n  next();\n}\n\nexport function createHandler(handler, middlewares = []) {\n  return async (req, res) => {\n    const runMiddleware = (middleware) => {\n      return new Promise((resolve, reject) => {\n        middleware(req, res, (result) => {\n          if (result instanceof Error) {\n            return reject(result);\n          }\n          return resolve(result);\n        });\n      });\n    };\n\n    try {\n      for (const middleware of middlewares) {\n        if (res.headersSent) {\n          return;\n        }\n        await runMiddleware(middleware);\n      }\n      \n      if (!res.headersSent) {\n        await handler(req, res);\n      }\n    } catch (error) {\n      if (!res.headersSent) {\n        console.error('Handler error:', error);\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    }\n  };\n}\n\nexport function sanitizeObject(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(sanitizeObject);\n  }\n\n  const sanitized = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key.startsWith('$') || key.includes('.')) {\n      continue;\n    }\n    sanitized[key] = sanitizeObject(value);\n  }\n  return sanitized;\n}\n","size_bytes":4178},"utils/auth.js":{"content":"import jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET;\n\nif (!JWT_SECRET) {\n  throw new Error('Please define JWT_SECRET environment variable');\n}\n\nexport function generateToken(userId, isAdmin = false) {\n  return jwt.sign({ userId, isAdmin }, JWT_SECRET, { expiresIn: '30d' });\n}\n\nexport function verifyToken(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch (error) {\n    return null;\n  }\n}\n\nexport function getUserFromRequest(req) {\n  const authHeader = req.headers.authorization;\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return null;\n  }\n\n  const token = authHeader.substring(7);\n  const decoded = verifyToken(token);\n  return decoded ? decoded.userId : null;\n}\n","size_bytes":725},"lib/schemas.js":{"content":"import { z } from 'zod';\n\nexport const registerSchema = z.object({\n  username: z.string().min(3).max(30).trim(),\n  email: z.string().email().toLowerCase(),\n  password: z.string().min(6).max(100),\n});\n\nexport const loginSchema = z.object({\n  email: z.string().email().toLowerCase(),\n  password: z.string().min(1),\n});\n\nexport const lastfmSchema = z.object({\n  lastfmUsername: z.string().min(1).max(50).trim(),\n});\n\nexport const createBattleSchema = z.object({\n  name: z.string().min(1).max(100).trim(),\n  spotifyPlaylist: z.string().min(1),\n  startTime: z.string().refine((val) => !isNaN(Date.parse(val)), {\n    message: 'Invalid date format',\n  }),\n  endTime: z.string().refine((val) => !isNaN(Date.parse(val)), {\n    message: 'Invalid date format',\n  }),\n}).refine((data) => new Date(data.endTime) > new Date(data.startTime), {\n  message: 'End time must be after start time',\n  path: ['endTime'],\n});\n\nexport const joinBattleSchema = z.object({\n  battleId: z.string().length(24),\n});\n\nexport const endBattleSchema = z.object({\n  battleId: z.string().length(24),\n});\n","size_bytes":1067},"utils/spotify.js":{"content":"import axios from 'axios';\n\nconst SPOTIFY_CLIENT_ID = process.env.SPOTIFY_CLIENT_ID;\nconst SPOTIFY_CLIENT_SECRET = process.env.SPOTIFY_CLIENT_SECRET;\n\nlet cachedToken = null;\nlet tokenExpiry = 0;\n\nasync function getSpotifyToken() {\n  if (cachedToken && Date.now() < tokenExpiry) {\n    return cachedToken;\n  }\n\n  const auth = Buffer.from(`${SPOTIFY_CLIENT_ID}:${SPOTIFY_CLIENT_SECRET}`).toString('base64');\n  \n  try {\n    const response = await axios.post(\n      'https://accounts.spotify.com/api/token',\n      'grant_type=client_credentials',\n      {\n        headers: {\n          'Authorization': `Basic ${auth}`,\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      }\n    );\n\n    cachedToken = response.data.access_token;\n    tokenExpiry = Date.now() + (response.data.expires_in * 1000) - 60000;\n    return cachedToken;\n  } catch (error) {\n    console.error('Error getting Spotify token:', error.response?.data || error.message);\n    throw new Error('Failed to authenticate with Spotify');\n  }\n}\n\nexport function extractPlaylistId(playlistUrl) {\n  const match = playlistUrl.match(/playlist\\/([a-zA-Z0-9]+)/);\n  return match ? match[1] : playlistUrl;\n}\n\nfunction normalizeText(text) {\n  return text\n    .toLowerCase()\n    .trim()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\\s+/g, ' ');\n}\n\nexport async function getPlaylistTracks(playlistId) {\n  const token = await getSpotifyToken();\n  const tracks = [];\n  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;\n\n  try {\n    while (url) {\n      const response = await axios.get(url, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n        },\n        params: {\n          limit: 100,\n          fields: 'items(track(name,artists(name))),next',\n        },\n      });\n\n      const items = response.data.items || [];\n      \n      for (const item of items) {\n        if (item.track && item.track.name && item.track.artists && item.track.artists.length > 0) {\n          const title = item.track.name;\n          const artist = item.track.artists[0].name;\n          \n          tracks.push({\n            title,\n            artist,\n            normalizedTitle: normalizeText(title),\n            normalizedArtist: normalizeText(artist),\n          });\n        }\n      }\n\n      url = response.data.next;\n    }\n\n    return tracks;\n  } catch (error) {\n    console.error('Error fetching playlist tracks:', error.response?.data || error.message);\n    throw new Error('Failed to fetch playlist tracks from Spotify');\n  }\n}\n","size_bytes":2544},"pages/api/socket.js":{"content":"import { Server } from 'socket.io';\n\nlet io;\n\nexport default function handler(req, res) {\n  if (!res.socket.server.io) {\n    console.log('Initializing Socket.io server...');\n    \n    io = new Server(res.socket.server, {\n      path: '/api/socket',\n      addTrailingSlash: false,\n      cors: {\n        origin: '*',\n        methods: ['GET', 'POST'],\n      },\n    });\n\n    res.socket.server.io = io;\n\n    io.on('connection', (socket) => {\n      console.log('Client connected:', socket.id);\n\n      socket.on('join-battle', (battleId) => {\n        socket.join(`battle-${battleId}`);\n        console.log(`Socket ${socket.id} joined battle-${battleId}`);\n      });\n\n      socket.on('leave-battle', (battleId) => {\n        socket.leave(`battle-${battleId}`);\n        console.log(`Socket ${socket.id} left battle-${battleId}`);\n      });\n\n      socket.on('disconnect', () => {\n        console.log('Client disconnected:', socket.id);\n      });\n    });\n\n    console.log('Socket.io server initialized');\n  } else {\n    console.log('Socket.io server already running');\n  }\n\n  res.end();\n}\n\nexport function getIO() {\n  if (!io) {\n    throw new Error('Socket.io not initialized');\n  }\n  return io;\n}\n","size_bytes":1184},"next.config.js":{"content":"/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  allowedDevOrigins: ['*'],\n}\n\nmodule.exports = nextConfig\n","size_bytes":146},"pages/api/battle/list.js":{"content":"import connectDB from '../../../utils/db';\nimport Battle from '../../../models/Battle';\nimport { createHandler, withCors } from '../../../lib/middleware';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const battles = await Battle.find()\n      .populate('host', 'username')\n      .sort({ createdAt: -1 })\n      .limit(50);\n\n    const battlesData = battles.map(battle => ({\n      id: battle._id,\n      name: battle.name,\n      host: battle.host.username,\n      startTime: battle.startTime,\n      endTime: battle.endTime,\n      status: battle.status,\n      participantCount: battle.participants.length,\n      trackCount: battle.playlistTracks.length,\n    }));\n\n    res.status(200).json({ battles: battlesData });\n  } catch (error) {\n    logger.error('Battle list error', { error: error.message });\n    res.status(500).json({ error: 'Server error fetching battles' });\n  }\n}\n\nexport default createHandler(handler, [withCors]);\n","size_bytes":1098},"app/layout.js":{"content":"export const metadata = {\n  title: 'ARMY Stream Battles',\n  description: 'Real-time music streaming battle platform',\n}\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body style={{ fontFamily: 'Arial, sans-serif', margin: '20px', backgroundColor: '#f5f5f5' }}>\n        {children}\n      </body>\n    </html>\n  )\n}\n","size_bytes":356},"pages/api/battle/join.js":{"content":"import connectDB from '../../../utils/db';\nimport Battle from '../../../models/Battle';\nimport User from '../../../models/User';\nimport mongoose from 'mongoose';\nimport { createHandler, withCors, withRateLimit, withAuth, withValidation } from '../../../lib/middleware';\nimport { joinBattleSchema } from '../../../lib/schemas';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const { battleId } = req.validatedBody;\n\n    if (!mongoose.Types.ObjectId.isValid(battleId)) {\n      return res.status(400).json({ error: 'Invalid battle ID' });\n    }\n\n    const user = await User.findById(req.userId);\n    if (!user || !user.lastfmUsername) {\n      return res.status(400).json({ error: 'Please set your Last.fm username before joining a battle' });\n    }\n\n    const battle = await Battle.findById(battleId);\n    if (!battle) {\n      return res.status(404).json({ error: 'Battle not found' });\n    }\n\n    if (battle.status === 'ended') {\n      return res.status(400).json({ error: 'This battle has already ended' });\n    }\n\n    const result = await Battle.findByIdAndUpdate(\n      battleId,\n      { $addToSet: { participants: req.userId } },\n      { new: true }\n    );\n\n    const isNewParticipant = result.participants.length > battle.participants.length;\n\n    if (isNewParticipant) {\n      logger.info('User joined battle', { userId: req.userId, battleId, battleName: battle.name });\n    }\n\n    res.status(200).json({\n      message: isNewParticipant ? 'Successfully joined battle' : 'You have already joined this battle',\n      battle: {\n        id: result._id,\n        name: result.name,\n        participantCount: result.participants.length,\n      },\n    });\n  } catch (error) {\n    logger.error('Battle join error', { error: error.message });\n    res.status(500).json({ error: 'Server error joining battle' });\n  }\n}\n\nexport default createHandler(handler, [\n  withCors,\n  withRateLimit(10, 60000),\n  withAuth(),\n  withValidation(joinBattleSchema),\n]);\n","size_bytes":2120},"pages/api/battle/verify.js":{"content":"import connectDB from '../../../utils/db';\nimport Battle from '../../../models/Battle';\nimport StreamCount from '../../../models/StreamCount';\nimport User from '../../../models/User';\nimport { getRecentTracks, matchTrack } from '../../../utils/lastfm';\nimport { logger } from '../../../utils/logger';\n\nlet verificationInterval = null;\nlet socketIO = null;\n\nfunction getSocketIO() {\n  try {\n    if (!socketIO) {\n      const socketModule = require('./socket');\n      socketIO = socketModule.getIO();\n    }\n    return socketIO;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction detectCheating(timestamps) {\n  if (timestamps.length < 11) return false;\n\n  const sortedTimestamps = [...timestamps].sort((a, b) => a - b);\n  \n  for (let i = 0; i <= sortedTimestamps.length - 11; i++) {\n    const windowStart = sortedTimestamps[i];\n    const windowEnd = sortedTimestamps[i + 10];\n    const windowDuration = (windowEnd - windowStart) / 1000 / 60;\n    \n    if (windowDuration <= 1) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nasync function freezeBattle(battle) {\n  try {\n    const streamCounts = await StreamCount.find({ battleId: battle._id }).populate('userId', 'username');\n    \n    const finalLeaderboard = streamCounts.map(sc => ({\n      userId: sc.userId._id,\n      username: sc.userId.username,\n      count: sc.count,\n      isCheater: sc.isCheater || false,\n    })).sort((a, b) => b.count - a.count);\n\n    await Battle.findByIdAndUpdate(battle._id, {\n      status: 'ended',\n      finalLeaderboard,\n      endedAt: new Date(),\n    });\n\n    logger.info('Battle frozen', { \n      battleId: battle._id, \n      battleName: battle.name,\n      participantCount: finalLeaderboard.length \n    });\n\n    const io = getSocketIO();\n    if (io) {\n      io.to(`battle-${battle._id}`).emit('battle-ended', {\n        battleId: battle._id,\n        leaderboard: finalLeaderboard,\n      });\n    }\n  } catch (error) {\n    logger.error('Error freezing battle', { battleId: battle._id, error: error.message });\n  }\n}\n\nasync function verifyScrobbles() {\n  try {\n    await connectDB();\n\n    const now = new Date();\n    \n    const upcomingToActive = await Battle.updateMany(\n      { status: 'upcoming', startTime: { $lte: now } },\n      { status: 'active' }\n    );\n\n    if (upcomingToActive.modifiedCount > 0) {\n      logger.info('Battles transitioned to active', { count: upcomingToActive.modifiedCount });\n    }\n\n    const activeBattlesToEnd = await Battle.find({ status: 'active', endTime: { $lte: now } });\n\n    for (const battle of activeBattlesToEnd) {\n      await freezeBattle(battle);\n    }\n\n    const activeBattles = await Battle.find({ status: 'active' });\n\n    logger.info('Verification cycle started', { \n      time: now.toISOString(), \n      activeBattles: activeBattles.length \n    });\n\n    for (const battle of activeBattles) {\n      const participants = await User.find({ _id: { $in: battle.participants } });\n\n      for (const participant of participants) {\n        if (!participant.lastfmUsername) {\n          continue;\n        }\n\n        try {\n          const recentTracks = await getRecentTracks(\n            participant.lastfmUsername,\n            battle.startTime.getTime(),\n            now.getTime()\n          );\n\n          const matchedTracks = recentTracks.filter(scrobble => {\n            const isInTimeRange = \n              scrobble.timestamp >= battle.startTime.getTime() &&\n              scrobble.timestamp <= battle.endTime.getTime();\n            \n            return isInTimeRange && matchTrack(scrobble, battle.playlistTracks);\n          });\n\n          const count = matchedTracks.length;\n          const timestamps = matchedTracks.map(t => t.timestamp);\n          const isCheater = detectCheating(timestamps);\n\n          await StreamCount.findOneAndUpdate(\n            { battleId: battle._id, userId: participant._id },\n            { \n              count, \n              isCheater,\n              scrobbleTimestamps: timestamps,\n            },\n            { upsert: true }\n          );\n\n          logger.info('Scrobbles verified', {\n            battleId: battle._id,\n            userId: participant._id,\n            username: participant.username,\n            scrobblesCounted: count,\n            playlistMatches: count,\n            isCheater,\n          });\n\n        } catch (error) {\n          logger.error('Error verifying scrobbles for user', { \n            username: participant.username, \n            battleId: battle._id,\n            error: error.message \n          });\n        }\n      }\n\n      const streamCounts = await StreamCount.find({ battleId: battle._id }).populate('userId', 'username');\n      \n      const participantIds = battle.participants.map(p => p.toString());\n      const existingUserIds = streamCounts.map(sc => sc.userId._id.toString());\n      \n      const missingParticipants = await User.find({\n        _id: { $in: participantIds.filter(id => !existingUserIds.includes(id)) }\n      });\n\n      const leaderboard = [\n        ...streamCounts.map(sc => ({\n          userId: sc.userId._id,\n          username: sc.userId.username,\n          count: sc.count,\n          isCheater: sc.isCheater || false,\n        })),\n        ...missingParticipants.map(p => ({\n          userId: p._id,\n          username: p.username,\n          count: 0,\n          isCheater: false,\n        })),\n      ].sort((a, b) => b.count - a.count);\n\n      const io = getSocketIO();\n      if (io) {\n        io.to(`battle-${battle._id}`).emit('leaderboard-update', {\n          battleId: battle._id,\n          leaderboard,\n          updatedAt: now.toISOString(),\n        });\n      }\n    }\n\n    logger.info('Verification cycle completed', { time: now.toISOString() });\n\n  } catch (error) {\n    logger.error('Verification error', { error: error.message, stack: error.stack });\n  }\n}\n\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  if (!verificationInterval) {\n    logger.info('Starting scrobble verification process');\n    \n    verificationInterval = setInterval(verifyScrobbles, 30000);\n    \n    verifyScrobbles();\n\n    res.status(200).json({ message: 'Verification process started' });\n  } else {\n    res.status(200).json({ message: 'Verification process already running' });\n  }\n}\n","size_bytes":6291},"models/User.js":{"content":"import mongoose from 'mongoose';\n\nconst UserSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    unique: true,\n    trim: true\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    trim: true,\n    lowercase: true\n  },\n  passwordHash: {\n    type: String,\n    required: true\n  },\n  lastfmUsername: {\n    type: String,\n    default: null,\n    trim: true\n  },\n  isAdmin: {\n    type: Boolean,\n    default: false\n  }\n}, {\n  timestamps: true\n});\n\nexport default mongoose.models.User || mongoose.model('User', UserSchema);\n","size_bytes":569},"README.md":{"content":"# ARMY Stream Battles\n\nA production-ready real-time music streaming battle platform where users compete by listening to Spotify playlists. The platform tracks plays through Last.fm scrobbles and displays live leaderboards with automatic cheat detection and battle lifecycle management.\n\n## Features\n\n### Core Features\n- **User Authentication**: Secure JWT-based authentication with bcrypt password hashing\n- **Last.fm Integration**: Connect your Last.fm account to track scrobbles automatically\n- **Battle Creation**: Create battles with Spotify playlists and custom time windows\n- **Real-time Leaderboards**: Live updates via Socket.io every 30 seconds\n- **Scrobble Verification**: Automatic verification of plays matching playlist tracks with normalized matching\n- **Battle Lifecycle Management**: Automatic transitions between upcoming → active → ended states\n\n### Production Enhancements\n- **Input Validation**: Zod validation on all API endpoints\n- **Rate Limiting**: Protection against API abuse on all POST endpoints\n- **Comprehensive Error Handling**: Structured error responses across all routes\n- **Cheat Detection**: Automatic flagging of users with >10 scrobbles per minute\n- **Frozen Results**: Battle results are frozen and saved when battles end\n- **Enhanced Logging**: Structured logging for all verification cycles and API operations\n- **MongoDB Retry Logic**: Automatic reconnection with exponential backoff\n- **Security**: Query sanitization, ObjectId validation, admin-only endpoints\n\n### Admin Features\n- **Manual Battle Control**: Admin-only endpoint to end battles manually\n- **Data Cleanup**: Automated cleanup of battles older than 7 days\n- **Admin Dashboard**: Special admin privileges for battle management\n\n## Tech Stack\n\n- **Frontend**: Next.js 14 (App Router), React, Socket.io-client\n- **Backend**: Next.js API Routes with middleware architecture\n- **Database**: MongoDB with Mongoose ODM\n- **Real-time**: Socket.io for live updates\n- **APIs**: Spotify Web API (client credentials), Last.fm API\n- **Authentication**: JWT with bcryptjs hashing\n- **Validation**: Zod for input validation\n- **Logging**: Structured logging with context\n\n## Prerequisites\n\nBefore running this application, you need:\n\n1. **MongoDB Database**: A MongoDB instance (MongoDB Atlas recommended)\n2. **Spotify API Credentials**: \n   - Register at https://developer.spotify.com/dashboard\n   - Create an app to get Client ID and Client Secret\n3. **Last.fm API Key**:\n   - Register at https://www.last.fm/api/account/create\n   - Get your API key\n\n## Environment Variables\n\nCreate a `.env` file in the root directory with the following variables:\n\n```env\nMONGO_URI=mongodb+srv://username:password@cluster.mongodb.net/army-stream-battles?retryWrites=true&w=majority\nJWT_SECRET=your-super-secret-jwt-key-change-this\nLASTFM_API_KEY=your-lastfm-api-key\nSPOTIFY_CLIENT_ID=your-spotify-client-id\nSPOTIFY_CLIENT_SECRET=your-spotify-client-secret\nLOG_LEVEL=INFO\n```\n\n### How to Get API Keys\n\n**MongoDB URI:**\n1. Go to https://www.mongodb.com/cloud/atlas\n2. Create a free cluster\n3. Click \"Connect\" → \"Connect your application\"\n4. Copy the connection string and replace `<password>` with your database password\n\n**Spotify Credentials:**\n1. Go to https://developer.spotify.com/dashboard\n2. Log in and create a new app\n3. Copy the Client ID and Client Secret\n\n**Last.fm API Key:**\n1. Go to https://www.last.fm/api/account/create\n2. Fill in the application details\n3. Copy the API Key (not the shared secret)\n\n## Installation\n\n1. **Install dependencies:**\n```bash\nnpm install\n```\n\n2. **Set up environment variables:**\n   - Copy `.env.example` to `.env`\n   - Fill in all required values\n\n## Running Locally\n\n1. **Development mode:**\n```bash\nnpm run dev\n```\n\n2. **Production build:**\n```bash\nnpm run build\nnpm start\n```\n\nThe application will run on http://localhost:5000\n\n## Running on Replit\n\n1. **Import this repository** to Replit\n\n2. **Add environment variables:**\n   - Click on \"Tools\" → \"Secrets\" in the Replit sidebar\n   - Add each environment variable from the `.env.example` file\n\n3. **The application will start automatically**\n   - Replit will run `npm install` and `npm run dev`\n   - Access your app via the provided Replit URL\n\n4. **To deploy on Replit:**\n   - Click the \"Deploy\" button\n   - Follow the deployment wizard\n   - Your app will be live with a public URL\n\n## How to Use\n\n1. **Sign Up**: Create an account with email and password\n2. **Connect Last.fm**: Set your Last.fm username in your profile (you'll see a \"✓ Connected\" indicator)\n3. **Create a Battle**: \n   - Enter battle name\n   - Paste a Spotify playlist URL (supports playlists with 100+ songs)\n   - Set start and end times\n4. **Join Battles**: Browse available battles and join (requires Last.fm connection)\n5. **Listen and Compete**: \n   - Listen to tracks from the playlist on any platform (Spotify, Apple Music, YouTube Music, etc.)\n   - Make sure you're scrobbling to Last.fm\n   - Watch the live leaderboard update every 30 seconds\n   - Check for the \"Flagged\" status if suspicious activity is detected\n\n## How Stream Verification Works\n\n### Verification Process\n\nEvery 30 seconds, the system performs the following steps:\n\n1. **Battle Lifecycle Check**:\n   - Transitions battles from \"upcoming\" to \"active\" when start time is reached\n   - Identifies battles that have ended\n\n2. **Scrobble Fetching** (Only for Active Battles):\n   - Queries Last.fm API for each participant's recent tracks\n   - Fetches tracks played between battle start time and current time\n\n3. **Track Matching**:\n   - Normalizes track names and artists (lowercase, removes diacritics, trims whitespace)\n   - Matches scrobbles against the playlist tracks\n   - Filters scrobbles that fall within the battle time window\n\n4. **Cheat Detection**:\n   - Analyzes scrobble timestamps for suspicious patterns\n   - Flags users with more than 10 scrobbles within any 1-minute window\n   - Marked participants show a \"⚠️ Flagged\" indicator on the leaderboard\n\n5. **Result Freezing** (When Battle Ends):\n   - Saves final leaderboard to database\n   - Stops querying Last.fm API for that battle\n   - Broadcasts \"battle-ended\" event via Socket.io\n\n6. **Real-time Updates**:\n   - Emits leaderboard updates via Socket.io\n   - Shows all participants (including those with 0 counts)\n   - Displays last updated timestamp\n\n### Cheat Prevention and Fair Play Rules\n\n**Automatic Cheat Detection:**\n- Users who log more than 10 scrobbles per minute are automatically flagged\n- Flagged users are highlighted on the leaderboard with a warning icon\n- Manual review by admins can override false positives\n\n**Fair Play Guidelines:**\n- Only tracks from the specified playlist count toward your score\n- Scrobbles must occur within the battle time window (start to end time)\n- Each scrobble is counted only once\n- Track must be scrobbled to Last.fm (any music platform works)\n\n**What Counts:**\n- ✅ Listening to playlist tracks on any platform (Spotify, Apple Music, etc.)\n- ✅ Scrobbles within the battle time window\n- ✅ Exact track and artist matches (normalized for comparison)\n\n**What Doesn't Count:**\n- ❌ Tracks not in the playlist\n- ❌ Scrobbles before battle start or after battle end\n- ❌ Artificially accelerated scrobbling (>10/minute)\n- ❌ Duplicate scrobbles (already handled by Last.fm)\n\n## Project Structure\n\n```\n/app                       # Next.js App Router pages\n  /battle/[id]/           # Battle detail page with live leaderboard\n  /dashboard/             # User dashboard\n  /login/                 # Login page\n  /signup/                # Sign up page\n/pages/api                # API routes with middleware\n  /admin/                 # Admin-only endpoints\n    cleanup.js            # Data cleanup endpoint\n    end-battle-manually.js # Manual battle end\n  /auth/                  # Authentication endpoints\n    register.js           # User registration\n    login.js              # User login\n  /battle/                # Battle management\n    create.js             # Create battle\n    join.js               # Join battle\n    list.js               # List battles\n    verify.js             # Verification process\n    /[id]/leaderboard.js  # Get leaderboard\n  /user/                  # User management\n    lastfm.js             # Set Last.fm username\n  socket.js               # Socket.io server\n/models                   # Mongoose schemas\n  User.js                 # User model (with isAdmin)\n  Battle.js               # Battle model (with lifecycle fields)\n  StreamCount.js          # Stream count model (with cheat detection)\n/lib                      # Shared libraries\n  middleware.js           # Reusable middleware (auth, validation, rate limiting)\n  schemas.js              # Zod validation schemas\n/utils                    # Utility functions\n  auth.js                 # JWT utilities\n  db.js                   # MongoDB connection with retry logic\n  spotify.js              # Spotify API integration with normalization\n  lastfm.js               # Last.fm API integration\n  logger.js               # Structured logging\n/scripts                  # Utility scripts\n  cleanupOldBattles.js    # Cleanup script for old battles\n```\n\n## API Reference\n\n### Authentication Endpoints\n\n#### POST /api/auth/register\nCreate a new user account.\n\n**Request:**\n```json\n{\n  \"username\": \"string (3-30 chars)\",\n  \"email\": \"string (valid email)\",\n  \"password\": \"string (min 6 chars)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"message\": \"User created successfully\",\n  \"token\": \"JWT token\",\n  \"user\": {\n    \"id\": \"user_id\",\n    \"username\": \"username\",\n    \"email\": \"email\",\n    \"lastfmUsername\": null,\n    \"isAdmin\": false\n  }\n}\n```\n\n**Rate Limit:** 5 requests per minute\n\n#### POST /api/auth/login\nLogin to existing account.\n\n**Request:**\n```json\n{\n  \"email\": \"string\",\n  \"password\": \"string\"\n}\n```\n\n**Response:** Same as register\n\n**Rate Limit:** 10 requests per minute\n\n### User Endpoints\n\n#### POST /api/user/lastfm\nSet or update Last.fm username (requires authentication).\n\n**Headers:** `Authorization: Bearer {token}`\n\n**Request:**\n```json\n{\n  \"lastfmUsername\": \"string (1-50 chars)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"message\": \"Last.fm username updated successfully\",\n  \"user\": { ...user object }\n}\n```\n\n**Rate Limit:** 10 requests per minute\n\n### Battle Endpoints\n\n#### POST /api/battle/create\nCreate a new battle (requires authentication).\n\n**Headers:** `Authorization: Bearer {token}`\n\n**Request:**\n```json\n{\n  \"name\": \"string (1-100 chars)\",\n  \"spotifyPlaylist\": \"string (playlist URL or ID)\",\n  \"startTime\": \"ISO 8601 datetime string\",\n  \"endTime\": \"ISO 8601 datetime string (must be after startTime)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"message\": \"Battle created successfully\",\n  \"battle\": {\n    \"id\": \"battle_id\",\n    \"name\": \"battle_name\",\n    \"spotifyPlaylist\": \"playlist_id\",\n    \"startTime\": \"2025-01-01T12:00:00Z\",\n    \"endTime\": \"2025-01-01T18:00:00Z\",\n    \"trackCount\": 50,\n    \"status\": \"upcoming\"\n  }\n}\n```\n\n**Rate Limit:** 5 requests per minute\n\n#### POST /api/battle/join\nJoin an existing battle (requires authentication and Last.fm username).\n\n**Headers:** `Authorization: Bearer {token}`\n\n**Request:**\n```json\n{\n  \"battleId\": \"string (24-char ObjectId)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"message\": \"Successfully joined battle\",\n  \"battle\": {\n    \"id\": \"battle_id\",\n    \"name\": \"battle_name\",\n    \"participantCount\": 5\n  }\n}\n```\n\n**Rate Limit:** 10 requests per minute\n\n#### GET /api/battle/list\nGet list of all battles (no authentication required).\n\n**Response:**\n```json\n{\n  \"battles\": [\n    {\n      \"id\": \"battle_id\",\n      \"name\": \"battle_name\",\n      \"host\": \"hostname\",\n      \"startTime\": \"2025-01-01T12:00:00Z\",\n      \"endTime\": \"2025-01-01T18:00:00Z\",\n      \"status\": \"active\",\n      \"participantCount\": 10,\n      \"trackCount\": 50\n    }\n  ]\n}\n```\n\n#### GET /api/battle/[id]/leaderboard\nGet battle leaderboard (no authentication required).\n\n**Response:**\n```json\n{\n  \"battleId\": \"battle_id\",\n  \"battleName\": \"battle_name\",\n  \"status\": \"active\",\n  \"startTime\": \"2025-01-01T12:00:00Z\",\n  \"endTime\": \"2025-01-01T18:00:00Z\",\n  \"participantCount\": 10,\n  \"leaderboard\": [\n    {\n      \"userId\": \"user_id\",\n      \"username\": \"username\",\n      \"count\": 42,\n      \"isCheater\": false\n    }\n  ],\n  \"updatedAt\": \"2025-01-01T15:30:00Z\"\n}\n```\n\n#### POST /api/battle/verify\nStart the scrobble verification process (no authentication required).\n\n**Response:**\n```json\n{\n  \"message\": \"Verification process started\"\n}\n```\n\n**Note:** This endpoint is automatically called by the dashboard on load.\n\n### Admin Endpoints\n\n#### POST /api/admin/end-battle-manually\nManually end a battle (requires admin authentication).\n\n**Headers:** `Authorization: Bearer {admin_token}`\n\n**Request:**\n```json\n{\n  \"battleId\": \"string (24-char ObjectId)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"message\": \"Battle ended successfully\",\n  \"battle\": {\n    \"id\": \"battle_id\",\n    \"name\": \"battle_name\",\n    \"status\": \"ended\",\n    \"finalLeaderboard\": [...]\n  }\n}\n```\n\n**Rate Limit:** 10 requests per minute\n\n#### GET /api/admin/cleanup\nClean up battles older than 7 days (requires admin authentication).\n\n**Headers:** `Authorization: Bearer {admin_token}`\n\n**Response:**\n```json\n{\n  \"message\": \"Cleanup completed successfully\",\n  \"summary\": {\n    \"battlesDeleted\": 5,\n    \"streamCountsDeleted\": 50,\n    \"orphanedStreamCountsDeleted\": 3\n  }\n}\n```\n\n**Rate Limit:** 2 requests per minute\n\n## Testing Admin Endpoints\n\n### Creating an Admin User\n\nAdmin users must be created manually in the database. To create an admin user:\n\n1. **Register a normal user** through the signup page\n2. **Access your MongoDB database** (via MongoDB Compass or Atlas)\n3. **Find the user** in the `users` collection\n4. **Update the user document:**\n   ```javascript\n   db.users.updateOne(\n     { email: \"admin@example.com\" },\n     { $set: { isAdmin: true } }\n   )\n   ```\n5. **Login again** to get a new JWT token with admin privileges\n\n### Testing Admin Endpoints\n\n**Using curl:**\n```bash\n# Get admin token by logging in\nTOKEN=\"your_admin_jwt_token\"\n\n# Manually end a battle\ncurl -X POST http://localhost:5000/api/admin/end-battle-manually \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"battleId\": \"battle_id_here\"}'\n\n# Run cleanup\ncurl -X GET http://localhost:5000/api/admin/cleanup \\\n  -H \"Authorization: Bearer $TOKEN\"\n```\n\n**Using JavaScript:**\n```javascript\nconst token = localStorage.getItem('token'); // Admin token\n\n// End battle manually\nawait fetch('/api/admin/end-battle-manually', {\n  method: 'POST',\n  headers: {\n    'Authorization': `Bearer ${token}`,\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({ battleId: 'battle_id_here' }),\n});\n\n// Run cleanup\nawait fetch('/api/admin/cleanup', {\n  method: 'GET',\n  headers: {\n    'Authorization': `Bearer ${token}`,\n  },\n});\n```\n\n## Confirming Battle Lifecycle Functionality\n\n### Manual Testing\n\n1. **Create a Test Battle:**\n   - Create a battle that starts in 1 minute and ends in 3 minutes\n   - Check the database - status should be \"upcoming\"\n\n2. **Wait for Start Time:**\n   - After 1 minute, check the database or battle page\n   - Status should automatically change to \"active\"\n   - Check server logs for: `Battles transitioned to active`\n\n3. **During Active Battle:**\n   - Join the battle\n   - Listen to playlist tracks and scrobble to Last.fm\n   - Watch the leaderboard update every 30 seconds\n   - Check logs for: `Verification cycle started` and `Scrobbles verified`\n\n4. **Wait for End Time:**\n   - After 3 minutes total, the battle should end automatically\n   - Status changes to \"ended\"\n   - Final leaderboard is frozen in the database\n   - Check logs for: `Battle frozen`\n   - Socket.io emits `battle-ended` event\n\n5. **After Battle Ends:**\n   - Leaderboard shows frozen results\n   - No more Last.fm queries for this battle\n   - Results persist even after server restart\n\n### Database Verification\n\nCheck the `battles` collection for these fields:\n```javascript\n{\n  status: \"ended\",           // Changed from \"active\"\n  finalLeaderboard: [...],   // Array of final results\n  endedAt: ISODate(\"...\"),   // Timestamp when frozen\n}\n```\n\n### Log Verification\n\nLook for these log messages:\n```\n[INFO] Battles transitioned to active { count: 1 }\n[INFO] Verification cycle started { time: \"...\", activeBattles: 1 }\n[INFO] Scrobbles verified { battleId: \"...\", username: \"...\", scrobblesCounted: 5 }\n[INFO] Battle frozen { battleId: \"...\", participantCount: 3 }\n[INFO] Verification cycle completed { time: \"...\" }\n```\n\n## Running Cleanup Script\n\nTo manually run the cleanup script:\n\n```bash\nnode scripts/cleanupOldBattles.js\n```\n\nThis will:\n- Find all battles with status \"ended\" and `endedAt` older than 7 days\n- Delete those battles and associated stream counts\n- Clean up orphaned stream counts\n\n## Troubleshooting\n\n**Database connection issues:**\n- Verify your MongoDB URI is correct\n- Check that your IP is whitelisted in MongoDB Atlas\n- Ensure the database user has proper permissions\n- Check logs for retry attempts\n\n**Spotify API errors:**\n- Verify your Client ID and Secret are correct\n- Make sure the playlist is public\n- Check that you haven't exceeded API rate limits\n- Playlists with 100+ songs are handled automatically\n\n**Last.fm not showing plays:**\n- Verify the Last.fm username is spelled correctly\n- Ensure scrobbling is enabled in your music player\n- Check that plays are within the battle time window\n- Confirm track names match (normalized comparison used)\n- Check logs for `Scrobbles verified` messages\n\n**Cheat detection false positives:**\n- Check `scrobbleTimestamps` in StreamCount collection\n- Verify timestamp distribution\n- Admin can manually review and override flags\n\n**Rate limiting errors:**\n- Wait for the retry time specified in the error\n- Rate limits reset every minute\n- Admin endpoints have stricter limits\n\n## License\n\nMIT\n","size_bytes":17864},"utils/lastfm.js":{"content":"import axios from 'axios';\n\nconst LASTFM_API_KEY = process.env.LASTFM_API_KEY;\n\nexport async function getRecentTracks(username, fromTimestamp, toTimestamp) {\n  try {\n    const response = await axios.get('http://ws.audioscrobbler.com/2.0/', {\n      params: {\n        method: 'user.getrecenttracks',\n        user: username,\n        api_key: LASTFM_API_KEY,\n        format: 'json',\n        from: Math.floor(fromTimestamp / 1000),\n        to: Math.floor(toTimestamp / 1000),\n        limit: 200,\n      },\n    });\n\n    if (!response.data.recenttracks || !response.data.recenttracks.track) {\n      return [];\n    }\n\n    const tracks = Array.isArray(response.data.recenttracks.track)\n      ? response.data.recenttracks.track\n      : [response.data.recenttracks.track];\n\n    return tracks\n      .filter(track => track.date)\n      .map(track => ({\n        name: track.name,\n        artist: track.artist['#text'] || track.artist.name || track.artist,\n        timestamp: parseInt(track.date.uts) * 1000,\n      }));\n  } catch (error) {\n    console.error(`Error fetching Last.fm tracks for ${username}:`, error.response?.data || error.message);\n    return [];\n  }\n}\n\nexport function normalizeString(str) {\n  return str\n    .toLowerCase()\n    .trim()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\\s+/g, ' ');\n}\n\nexport function matchTrack(scrobble, playlistTracks) {\n  const scrobbleName = normalizeString(scrobble.name);\n  const scrobbleArtist = normalizeString(scrobble.artist);\n\n  return playlistTracks.some(track => {\n    const trackName = track.normalizedTitle || normalizeString(track.title);\n    const trackArtist = track.normalizedArtist || normalizeString(track.artist);\n    return scrobbleName === trackName && scrobbleArtist === trackArtist;\n  });\n}\n","size_bytes":1774},"pages/api/battle/[id]/leaderboard.js":{"content":"import connectDB from '../../../../utils/db';\nimport Battle from '../../../../models/Battle';\nimport StreamCount from '../../../../models/StreamCount';\nimport User from '../../../../models/User';\nimport mongoose from 'mongoose';\nimport { createHandler, withCors } from '../../../../lib/middleware';\nimport { logger } from '../../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const { id } = req.query;\n\n    if (!mongoose.Types.ObjectId.isValid(id)) {\n      return res.status(400).json({ error: 'Invalid battle ID' });\n    }\n\n    const battle = await Battle.findById(id).populate('participants', 'username');\n    if (!battle) {\n      return res.status(404).json({ error: 'Battle not found' });\n    }\n\n    let leaderboard;\n\n    if (battle.status === 'ended' && battle.finalLeaderboard && battle.finalLeaderboard.length > 0) {\n      leaderboard = battle.finalLeaderboard;\n    } else {\n      const streamCounts = await StreamCount.find({ battleId: id }).populate('userId', 'username');\n\n      const participantIds = battle.participants.map(p => p._id.toString());\n      const existingUserIds = streamCounts.map(sc => sc.userId._id.toString());\n      \n      const missingParticipants = battle.participants.filter(\n        p => !existingUserIds.includes(p._id.toString())\n      );\n\n      leaderboard = [\n        ...streamCounts.map(sc => ({\n          userId: sc.userId._id,\n          username: sc.userId.username,\n          count: sc.count,\n          isCheater: sc.isCheater || false,\n        })),\n        ...missingParticipants.map(p => ({\n          userId: p._id,\n          username: p.username,\n          count: 0,\n          isCheater: false,\n        })),\n      ].sort((a, b) => b.count - a.count);\n    }\n\n    res.status(200).json({\n      battleId: id,\n      battleName: battle.name,\n      status: battle.status,\n      startTime: battle.startTime,\n      endTime: battle.endTime,\n      participantCount: battle.participants.length,\n      leaderboard,\n      updatedAt: new Date().toISOString(),\n    });\n  } catch (error) {\n    logger.error('Leaderboard fetch error', { error: error.message, battleId: req.query.id });\n    res.status(500).json({ error: 'Server error fetching leaderboard' });\n  }\n}\n\nexport default createHandler(handler, [withCors]);\n","size_bytes":2392},"pages/api/battle/create.js":{"content":"import connectDB from '../../../utils/db';\nimport Battle from '../../../models/Battle';\nimport { extractPlaylistId, getPlaylistTracks } from '../../../utils/spotify';\nimport { createHandler, withCors, withRateLimit, withAuth, withValidation } from '../../../lib/middleware';\nimport { createBattleSchema } from '../../../lib/schemas';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const { name, spotifyPlaylist, startTime, endTime } = req.validatedBody;\n\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n\n    const playlistId = extractPlaylistId(spotifyPlaylist);\n    \n    logger.info('Fetching Spotify playlist tracks', { playlistId });\n    const playlistTracks = await getPlaylistTracks(playlistId);\n\n    if (playlistTracks.length === 0) {\n      return res.status(400).json({ error: 'No tracks found in playlist' });\n    }\n\n    const battle = await Battle.create({\n      host: req.userId,\n      name,\n      spotifyPlaylist: playlistId,\n      playlistTracks,\n      startTime: start,\n      endTime: end,\n      participants: [req.userId],\n      status: 'upcoming',\n    });\n\n    logger.info('Battle created successfully', { \n      battleId: battle._id, \n      name: battle.name, \n      trackCount: playlistTracks.length \n    });\n\n    res.status(201).json({\n      message: 'Battle created successfully',\n      battle: {\n        id: battle._id,\n        name: battle.name,\n        spotifyPlaylist: battle.spotifyPlaylist,\n        startTime: battle.startTime,\n        endTime: battle.endTime,\n        trackCount: battle.playlistTracks.length,\n        status: battle.status,\n      },\n    });\n  } catch (error) {\n    logger.error('Battle creation error', { error: error.message });\n    res.status(500).json({ error: 'Server error creating battle' });\n  }\n}\n\nexport default createHandler(handler, [\n  withCors,\n  withRateLimit(5, 60000),\n  withAuth(),\n  withValidation(createBattleSchema),\n]);\n","size_bytes":2085},"pages/api/admin/end-battle-manually.js":{"content":"import connectDB from '../../../utils/db';\nimport Battle from '../../../models/Battle';\nimport StreamCount from '../../../models/StreamCount';\nimport mongoose from 'mongoose';\nimport { createHandler, withCors, withRateLimit, withAuth, withValidation } from '../../../lib/middleware';\nimport { endBattleSchema } from '../../../lib/schemas';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const { battleId } = req.validatedBody;\n\n    if (!mongoose.Types.ObjectId.isValid(battleId)) {\n      return res.status(400).json({ error: 'Invalid battle ID' });\n    }\n\n    const battle = await Battle.findById(battleId);\n    if (!battle) {\n      return res.status(404).json({ error: 'Battle not found' });\n    }\n\n    if (battle.status === 'ended') {\n      return res.status(400).json({ error: 'Battle has already ended' });\n    }\n\n    const streamCounts = await StreamCount.find({ battleId }).populate('userId', 'username');\n\n    const finalLeaderboard = streamCounts.map(sc => ({\n      userId: sc.userId._id,\n      username: sc.userId.username,\n      count: sc.count,\n      isCheater: sc.isCheater || false,\n    })).sort((a, b) => b.count - a.count);\n\n    await Battle.findByIdAndUpdate(battleId, {\n      status: 'ended',\n      finalLeaderboard,\n      endedAt: new Date(),\n    });\n\n    logger.info('Battle manually ended by admin', {\n      battleId,\n      battleName: battle.name,\n      adminId: req.userId,\n      participantCount: finalLeaderboard.length,\n    });\n\n    res.status(200).json({\n      message: 'Battle ended successfully',\n      battle: {\n        id: battleId,\n        name: battle.name,\n        status: 'ended',\n        finalLeaderboard,\n      },\n    });\n  } catch (error) {\n    logger.error('Error manually ending battle', { error: error.message });\n    res.status(500).json({ error: 'Server error ending battle' });\n  }\n}\n\nexport default createHandler(handler, [\n  withCors,\n  withRateLimit(10, 60000),\n  withAuth({ requireAdmin: true }),\n  withValidation(endBattleSchema),\n]);\n","size_bytes":2158},"scripts/cleanupOldBattles.js":{"content":"import mongoose from 'mongoose';\nimport connectDB from '../utils/db.js';\nimport Battle from '../models/Battle.js';\nimport StreamCount from '../models/StreamCount.js';\n\nasync function cleanup() {\n  try {\n    console.log('Starting cleanup of old battles...');\n    \n    await connectDB();\n\n    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n\n    const oldBattles = await Battle.find({\n      status: 'ended',\n      endedAt: { $lte: sevenDaysAgo },\n    });\n\n    console.log(`Found ${oldBattles.length} battles older than 7 days`);\n\n    const battleIds = oldBattles.map(b => b._id);\n\n    const deletedStreamCounts = await StreamCount.deleteMany({\n      battleId: { $in: battleIds },\n    });\n\n    console.log(`Deleted ${deletedStreamCounts.deletedCount} stream counts`);\n\n    const deletedBattles = await Battle.deleteMany({\n      _id: { $in: battleIds },\n    });\n\n    console.log(`Deleted ${deletedBattles.deletedCount} battles`);\n\n    const allBattleIds = await Battle.find().distinct('_id');\n    const orphanedStreamCounts = await StreamCount.deleteMany({\n      battleId: { $nin: allBattleIds },\n    });\n\n    console.log(`Deleted ${orphanedStreamCounts.deletedCount} orphaned stream counts`);\n\n    console.log('Cleanup completed successfully');\n\n    await mongoose.connection.close();\n    process.exit(0);\n  } catch (error) {\n    console.error('Cleanup error:', error);\n    process.exit(1);\n  }\n}\n\ncleanup();\n","size_bytes":1427},"models/StreamCount.js":{"content":"import mongoose from 'mongoose';\n\nconst StreamCountSchema = new mongoose.Schema({\n  battleId: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'Battle',\n    required: true\n  },\n  userId: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  count: {\n    type: Number,\n    default: 0\n  },\n  isCheater: {\n    type: Boolean,\n    default: false\n  },\n  scrobbleTimestamps: [{\n    type: Number\n  }]\n}, {\n  timestamps: true\n});\n\nStreamCountSchema.index({ battleId: 1, userId: 1 }, { unique: true });\n\nexport default mongoose.models.StreamCount || mongoose.model('StreamCount', StreamCountSchema);\n","size_bytes":627},"pages/api/auth/login.js":{"content":"import bcrypt from 'bcryptjs';\nimport connectDB from '../../../utils/db';\nimport User from '../../../models/User';\nimport { generateToken } from '../../../utils/auth';\nimport { createHandler, withCors, withRateLimit, withValidation } from '../../../lib/middleware';\nimport { loginSchema } from '../../../lib/schemas';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const { email, password } = req.validatedBody;\n\n    const user = await User.findOne({ email });\n    if (!user) {\n      logger.warn('Login attempt with non-existent email', { email });\n      return res.status(401).json({ error: 'Invalid email or password' });\n    }\n\n    const isValidPassword = await bcrypt.compare(password, user.passwordHash);\n    if (!isValidPassword) {\n      logger.warn('Login attempt with invalid password', { email });\n      return res.status(401).json({ error: 'Invalid email or password' });\n    }\n\n    const token = generateToken(user._id.toString(), user.isAdmin);\n\n    logger.info('User logged in successfully', { userId: user._id, username: user.username });\n\n    res.status(200).json({\n      message: 'Login successful',\n      token,\n      user: {\n        id: user._id,\n        username: user.username,\n        email: user.email,\n        lastfmUsername: user.lastfmUsername,\n        isAdmin: user.isAdmin,\n      },\n    });\n  } catch (error) {\n    logger.error('Login error', { error: error.message });\n    res.status(500).json({ error: 'Server error during login' });\n  }\n}\n\nexport default createHandler(handler, [\n  withCors,\n  withRateLimit(10, 60000),\n  withValidation(loginSchema),\n]);\n","size_bytes":1760},"app/login/page.js":{"content":"'use client';\n\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport Link from 'next/link';\n\nexport default function Login() {\n  const router = useRouter();\n  const [formData, setFormData] = useState({\n    email: '',\n    password: '',\n  });\n  const [error, setError] = useState('');\n  const [loading, setLoading] = useState(false);\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError('');\n    setLoading(true);\n\n    try {\n      const res = await fetch('/api/auth/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(formData),\n      });\n\n      const data = await res.json();\n\n      if (!res.ok) {\n        throw new Error(data.error || 'Login failed');\n      }\n\n      localStorage.setItem('token', data.token);\n      localStorage.setItem('user', JSON.stringify(data.user));\n      router.push('/dashboard');\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div style={{ maxWidth: '400px', margin: '50px auto' }}>\n      <h1>Login</h1>\n      <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n        <input\n          type=\"email\"\n          placeholder=\"Email\"\n          value={formData.email}\n          onChange={(e) => setFormData({ ...formData, email: e.target.value })}\n          required\n          style={{ padding: '10px', fontSize: '16px' }}\n        />\n        <input\n          type=\"password\"\n          placeholder=\"Password\"\n          value={formData.password}\n          onChange={(e) => setFormData({ ...formData, password: e.target.value })}\n          required\n          style={{ padding: '10px', fontSize: '16px' }}\n        />\n        {error && <p style={{ color: 'red' }}>{error}</p>}\n        <button type=\"submit\" disabled={loading} style={{ padding: '10px', fontSize: '16px', cursor: 'pointer' }}>\n          {loading ? 'Logging in...' : 'Login'}\n        </button>\n      </form>\n      <p style={{ marginTop: '20px' }}>\n        Don't have an account? <Link href=\"/signup\">Sign Up</Link>\n      </p>\n    </div>\n  );\n}\n","size_bytes":2163},"models/Battle.js":{"content":"import mongoose from 'mongoose';\n\nconst BattleSchema = new mongoose.Schema({\n  host: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  name: {\n    type: String,\n    required: true,\n    trim: true\n  },\n  spotifyPlaylist: {\n    type: String,\n    required: true\n  },\n  playlistTracks: [{\n    title: {\n      type: String,\n      required: true\n    },\n    artist: {\n      type: String,\n      required: true\n    },\n    normalizedTitle: String,\n    normalizedArtist: String\n  }],\n  startTime: {\n    type: Date,\n    required: true\n  },\n  endTime: {\n    type: Date,\n    required: true\n  },\n  participants: [{\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User'\n  }],\n  status: {\n    type: String,\n    enum: ['upcoming', 'active', 'ended'],\n    default: 'upcoming'\n  },\n  finalLeaderboard: [{\n    userId: mongoose.Schema.Types.ObjectId,\n    username: String,\n    count: Number,\n    isCheater: Boolean\n  }],\n  endedAt: Date\n}, {\n  timestamps: true\n});\n\nexport default mongoose.models.Battle || mongoose.model('Battle', BattleSchema);\n","size_bytes":1065},"app/dashboard/page.js":{"content":"'use client';\n\nimport { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport Link from 'next/link';\n\nexport default function Dashboard() {\n  const router = useRouter();\n  const [user, setUser] = useState(null);\n  const [battles, setBattles] = useState([]);\n  const [showCreateForm, setShowCreateForm] = useState(false);\n  const [showLastfmForm, setShowLastfmForm] = useState(false);\n  const [lastfmUsername, setLastfmUsername] = useState('');\n  const [battleForm, setBattleForm] = useState({\n    name: '',\n    spotifyPlaylist: '',\n    startTime: '',\n    endTime: '',\n  });\n  const [error, setError] = useState('');\n  const [success, setSuccess] = useState('');\n\n  useEffect(() => {\n    const token = localStorage.getItem('token');\n    const userData = localStorage.getItem('user');\n    \n    if (!token) {\n      router.push('/login');\n      return;\n    }\n\n    if (userData) {\n      const parsedUser = JSON.parse(userData);\n      setUser(parsedUser);\n      setLastfmUsername(parsedUser.lastfmUsername || '');\n    }\n\n    fetchBattles();\n    startVerification();\n  }, [router]);\n\n  const startVerification = async () => {\n    try {\n      await fetch('/api/battle/verify', { method: 'POST' });\n    } catch (err) {\n      console.error('Failed to start verification:', err);\n    }\n  };\n\n  const fetchBattles = async () => {\n    try {\n      const res = await fetch('/api/battle/list');\n      const data = await res.json();\n      if (res.ok) {\n        setBattles(data.battles);\n      }\n    } catch (err) {\n      console.error('Failed to fetch battles:', err);\n    }\n  };\n\n  const handleLogout = () => {\n    localStorage.removeItem('token');\n    localStorage.removeItem('user');\n    router.push('/login');\n  };\n\n  const handleLastfmSubmit = async (e) => {\n    e.preventDefault();\n    setError('');\n    setSuccess('');\n\n    try {\n      const token = localStorage.getItem('token');\n      const res = await fetch('/api/user/lastfm', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`,\n        },\n        body: JSON.stringify({ lastfmUsername }),\n      });\n\n      const data = await res.json();\n\n      if (!res.ok) {\n        throw new Error(data.error || 'Failed to update Last.fm username');\n      }\n\n      localStorage.setItem('user', JSON.stringify(data.user));\n      setUser(data.user);\n      setSuccess('Last.fm username updated successfully!');\n      setShowLastfmForm(false);\n    } catch (err) {\n      setError(err.message);\n    }\n  };\n\n  const handleBattleSubmit = async (e) => {\n    e.preventDefault();\n    setError('');\n    setSuccess('');\n\n    try {\n      const token = localStorage.getItem('token');\n      const res = await fetch('/api/battle/create', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`,\n        },\n        body: JSON.stringify(battleForm),\n      });\n\n      const data = await res.json();\n\n      if (!res.ok) {\n        throw new Error(data.error || 'Failed to create battle');\n      }\n\n      setSuccess('Battle created successfully!');\n      setShowCreateForm(false);\n      setBattleForm({ name: '', spotifyPlaylist: '', startTime: '', endTime: '' });\n      fetchBattles();\n    } catch (err) {\n      setError(err.message);\n    }\n  };\n\n  const handleJoinBattle = async (battleId) => {\n    setError('');\n    setSuccess('');\n\n    try {\n      const token = localStorage.getItem('token');\n      const res = await fetch('/api/battle/join', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`,\n        },\n        body: JSON.stringify({ battleId }),\n      });\n\n      const data = await res.json();\n\n      if (!res.ok) {\n        throw new Error(data.error || 'Failed to join battle');\n      }\n\n      setSuccess('Joined battle successfully!');\n      fetchBattles();\n    } catch (err) {\n      setError(err.message);\n    }\n  };\n\n  if (!user) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div style={{ maxWidth: '800px', margin: '20px auto' }}>\n      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n        <h1>Dashboard</h1>\n        <button onClick={handleLogout} style={{ padding: '8px 16px' }}>Logout</button>\n      </div>\n\n      <div style={{ marginBottom: '20px', padding: '15px', backgroundColor: 'white', borderRadius: '5px' }}>\n        <p><strong>Username:</strong> {user.username}</p>\n        <p><strong>Email:</strong> {user.email}</p>\n        <p>\n          <strong>Last.fm:</strong> {user.lastfmUsername ? (\n            <span style={{ color: 'green' }}>\n              {user.lastfmUsername} <span style={{ marginLeft: '5px' }}>✓</span> Connected\n            </span>\n          ) : (\n            <span style={{ color: 'orange' }}>Not connected</span>\n          )}\n        </p>\n        <button onClick={() => setShowLastfmForm(!showLastfmForm)} style={{ padding: '8px 16px', marginTop: '10px' }}>\n          {user.lastfmUsername ? 'Update Last.fm Username' : 'Connect Last.fm Account'}\n        </button>\n      </div>\n\n      {showLastfmForm && (\n        <div style={{ marginBottom: '20px', padding: '15px', backgroundColor: 'white', borderRadius: '5px' }}>\n          <h3>Set Last.fm Username</h3>\n          <form onSubmit={handleLastfmSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n            <input\n              type=\"text\"\n              placeholder=\"Last.fm Username\"\n              value={lastfmUsername}\n              onChange={(e) => setLastfmUsername(e.target.value)}\n              required\n              style={{ padding: '10px', fontSize: '16px' }}\n            />\n            <button type=\"submit\" style={{ padding: '10px', fontSize: '16px' }}>Save</button>\n          </form>\n        </div>\n      )}\n\n      {error && <p style={{ color: 'red', padding: '10px', backgroundColor: 'white' }}>{error}</p>}\n      {success && <p style={{ color: 'green', padding: '10px', backgroundColor: 'white' }}>{success}</p>}\n\n      <div style={{ marginBottom: '20px' }}>\n        <button onClick={() => setShowCreateForm(!showCreateForm)} style={{ padding: '10px 20px', fontSize: '16px', marginRight: '10px' }}>\n          Create Battle\n        </button>\n      </div>\n\n      {showCreateForm && (\n        <div style={{ marginBottom: '20px', padding: '15px', backgroundColor: 'white', borderRadius: '5px' }}>\n          <h3>Create New Battle</h3>\n          <form onSubmit={handleBattleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n            <input\n              type=\"text\"\n              placeholder=\"Battle Name\"\n              value={battleForm.name}\n              onChange={(e) => setBattleForm({ ...battleForm, name: e.target.value })}\n              required\n              style={{ padding: '10px', fontSize: '16px' }}\n            />\n            <input\n              type=\"text\"\n              placeholder=\"Spotify Playlist URL or ID\"\n              value={battleForm.spotifyPlaylist}\n              onChange={(e) => setBattleForm({ ...battleForm, spotifyPlaylist: e.target.value })}\n              required\n              style={{ padding: '10px', fontSize: '16px' }}\n            />\n            <input\n              type=\"datetime-local\"\n              placeholder=\"Start Time\"\n              value={battleForm.startTime}\n              onChange={(e) => setBattleForm({ ...battleForm, startTime: e.target.value })}\n              required\n              style={{ padding: '10px', fontSize: '16px' }}\n            />\n            <input\n              type=\"datetime-local\"\n              placeholder=\"End Time\"\n              value={battleForm.endTime}\n              onChange={(e) => setBattleForm({ ...battleForm, endTime: e.target.value })}\n              required\n              style={{ padding: '10px', fontSize: '16px' }}\n            />\n            <button type=\"submit\" style={{ padding: '10px', fontSize: '16px' }}>Create Battle</button>\n          </form>\n        </div>\n      )}\n\n      <h2>Available Battles</h2>\n      <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n        {battles.length === 0 ? (\n          <p>No battles available. Create one!</p>\n        ) : (\n          battles.map((battle) => (\n            <div key={battle.id} style={{ padding: '15px', backgroundColor: 'white', borderRadius: '5px' }}>\n              <h3>{battle.name}</h3>\n              <p><strong>Host:</strong> {battle.host}</p>\n              <p><strong>Status:</strong> {battle.status}</p>\n              <p><strong>Participants:</strong> {battle.participantCount}</p>\n              <p><strong>Tracks:</strong> {battle.trackCount}</p>\n              <p><strong>Start:</strong> {new Date(battle.startTime).toLocaleString()}</p>\n              <p><strong>End:</strong> {new Date(battle.endTime).toLocaleString()}</p>\n              <div style={{ marginTop: '10px' }}>\n                <button onClick={() => handleJoinBattle(battle.id)} style={{ padding: '8px 16px', marginRight: '10px' }}>\n                  Join Battle\n                </button>\n                <Link href={`/battle/${battle.id}`}>\n                  <button style={{ padding: '8px 16px' }}>View Battle</button>\n                </Link>\n              </div>\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n","size_bytes":9383},"pages/api/auth/register.js":{"content":"import bcrypt from 'bcryptjs';\nimport connectDB from '../../../utils/db';\nimport User from '../../../models/User';\nimport { generateToken } from '../../../utils/auth';\nimport { createHandler, withCors, withRateLimit, withValidation } from '../../../lib/middleware';\nimport { registerSchema } from '../../../lib/schemas';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const { username, email, password } = req.validatedBody;\n\n    const existingUser = await User.findOne({ $or: [{ email }, { username }] });\n    if (existingUser) {\n      logger.warn('Registration attempt with existing credentials', { email, username });\n      return res.status(400).json({ error: 'User with this email or username already exists' });\n    }\n\n    const passwordHash = await bcrypt.hash(password, 10);\n\n    const user = await User.create({\n      username,\n      email,\n      passwordHash,\n      isAdmin: false,\n    });\n\n    const token = generateToken(user._id.toString(), user.isAdmin);\n\n    logger.info('User registered successfully', { userId: user._id, username: user.username });\n\n    res.status(201).json({\n      message: 'User created successfully',\n      token,\n      user: {\n        id: user._id,\n        username: user.username,\n        email: user.email,\n        lastfmUsername: user.lastfmUsername,\n        isAdmin: user.isAdmin,\n      },\n    });\n  } catch (error) {\n    logger.error('Registration error', { error: error.message });\n    res.status(500).json({ error: 'Server error during registration' });\n  }\n}\n\nexport default createHandler(handler, [\n  withCors,\n  withRateLimit(5, 60000),\n  withValidation(registerSchema),\n]);\n","size_bytes":1798},"utils/db.js":{"content":"import mongoose from 'mongoose';\n\nconst MONGO_URI = process.env.MONGO_URI;\n\nif (!MONGO_URI) {\n  throw new Error('Please define MONGO_URI environment variable');\n}\n\nlet cached = global.mongoose;\n\nif (!cached) {\n  cached = global.mongoose = { conn: null, promise: null };\n}\n\nasync function connectDB(retries = 5, delay = 1000) {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n      maxPoolSize: 10,\n      serverSelectionTimeoutMS: 5000,\n      socketTimeoutMS: 45000,\n    };\n\n    cached.promise = (async () => {\n      let lastError;\n      for (let i = 0; i < retries; i++) {\n        try {\n          const conn = await mongoose.connect(MONGO_URI, opts);\n          console.log('MongoDB connected successfully');\n          return conn;\n        } catch (error) {\n          lastError = error;\n          console.error(`MongoDB connection attempt ${i + 1}/${retries} failed:`, error.message);\n          if (i < retries - 1) {\n            await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));\n          }\n        }\n      }\n      throw lastError;\n    })();\n  }\n\n  try {\n    cached.conn = await cached.promise;\n  } catch (e) {\n    cached.promise = null;\n    throw e;\n  }\n\n  return cached.conn;\n}\n\nexport default connectDB;\n","size_bytes":1307},"app/page.js":{"content":"'use client';\n\nimport { useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\n\nexport default function Home() {\n  const router = useRouter();\n\n  useEffect(() => {\n    const token = localStorage.getItem('token');\n    if (token) {\n      router.push('/dashboard');\n    } else {\n      router.push('/login');\n    }\n  }, [router]);\n\n  return (\n    <div>\n      <h1>ARMY Stream Battles</h1>\n      <p>Loading...</p>\n    </div>\n  );\n}\n","size_bytes":442},"utils/logger.js":{"content":"const LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n};\n\nconst currentLevel = LOG_LEVELS[process.env.LOG_LEVEL || 'INFO'];\n\nfunction formatMessage(level, message, context = {}) {\n  const timestamp = new Date().toISOString();\n  const contextStr = Object.keys(context).length > 0 ? JSON.stringify(context) : '';\n  return `[${timestamp}] [${level}] ${message} ${contextStr}`;\n}\n\nexport const logger = {\n  error: (message, context) => {\n    if (currentLevel >= LOG_LEVELS.ERROR) {\n      console.error(formatMessage('ERROR', message, context));\n    }\n  },\n  \n  warn: (message, context) => {\n    if (currentLevel >= LOG_LEVELS.WARN) {\n      console.warn(formatMessage('WARN', message, context));\n    }\n  },\n  \n  info: (message, context) => {\n    if (currentLevel >= LOG_LEVELS.INFO) {\n      console.log(formatMessage('INFO', message, context));\n    }\n  },\n  \n  debug: (message, context) => {\n    if (currentLevel >= LOG_LEVELS.DEBUG) {\n      console.log(formatMessage('DEBUG', message, context));\n    }\n  },\n};\n","size_bytes":1019},"app/battle/[id]/page.js":{"content":"'use client';\n\nimport { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { io } from 'socket.io-client';\nimport Link from 'next/link';\n\nexport default function BattlePage({ params }) {\n  const router = useRouter();\n  const [battle, setBattle] = useState(null);\n  const [leaderboard, setLeaderboard] = useState([]);\n  const [socket, setSocket] = useState(null);\n  const [error, setError] = useState('');\n  const [lastUpdated, setLastUpdated] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    const token = localStorage.getItem('token');\n    if (!token) {\n      router.push('/login');\n      return;\n    }\n\n    const battleId = params.id;\n    fetchLeaderboard(battleId);\n\n    const socketInstance = io({\n      path: '/api/socket',\n    });\n\n    socketInstance.on('connect', () => {\n      console.log('Socket connected');\n      socketInstance.emit('join-battle', battleId);\n    });\n\n    socketInstance.on('leaderboard-update', (data) => {\n      if (data.battleId === battleId) {\n        setLeaderboard(data.leaderboard);\n        setLastUpdated(data.updatedAt);\n      }\n    });\n\n    socketInstance.on('battle-ended', (data) => {\n      if (data.battleId === battleId) {\n        setBattle(prev => ({ ...prev, status: 'ended' }));\n        setLeaderboard(data.leaderboard);\n      }\n    });\n\n    socketInstance.on('disconnect', () => {\n      console.log('Socket disconnected');\n    });\n\n    setSocket(socketInstance);\n\n    const interval = setInterval(() => {\n      fetchLeaderboard(battleId);\n    }, 10000);\n\n    return () => {\n      if (socketInstance) {\n        socketInstance.emit('leave-battle', battleId);\n        socketInstance.disconnect();\n      }\n      clearInterval(interval);\n    };\n  }, [params.id, router]);\n\n  const fetchLeaderboard = async (battleId) => {\n    try {\n      setLoading(true);\n      const res = await fetch(`/api/battle/${battleId}/leaderboard`);\n      const data = await res.json();\n\n      if (!res.ok) {\n        throw new Error(data.error || 'Failed to fetch leaderboard');\n      }\n\n      setBattle({\n        name: data.battleName,\n        status: data.status,\n        startTime: data.startTime,\n        endTime: data.endTime,\n        participantCount: data.participantCount,\n      });\n      setLeaderboard(data.leaderboard);\n      setLastUpdated(data.updatedAt);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (error) {\n    return (\n      <div style={{ maxWidth: '800px', margin: '20px auto' }}>\n        <p style={{ color: 'red' }}>{error}</p>\n        <Link href=\"/dashboard\">\n          <button style={{ padding: '10px 20px', marginTop: '10px' }}>Back to Dashboard</button>\n        </Link>\n      </div>\n    );\n  }\n\n  if (!battle) {\n    return <div style={{ maxWidth: '800px', margin: '20px auto' }}>\n      <div style={{ textAlign: 'center', padding: '50px' }}>\n        <div style={{ fontSize: '18px', color: '#666' }}>Loading battle...</div>\n      </div>\n    </div>;\n  }\n\n  return (\n    <div style={{ maxWidth: '800px', margin: '20px auto' }}>\n      <Link href=\"/dashboard\">\n        <button style={{ padding: '10px 20px', marginBottom: '20px' }}>← Back to Dashboard</button>\n      </Link>\n\n      <h1>{battle.name}</h1>\n      \n      <div style={{ backgroundColor: 'white', padding: '15px', marginBottom: '20px', borderRadius: '5px' }}>\n        <p><strong>Status:</strong> <span style={{ textTransform: 'uppercase', color: battle.status === 'active' ? 'green' : battle.status === 'ended' ? 'red' : 'orange' }}>{battle.status}</span></p>\n        <p><strong>Start Time:</strong> {new Date(battle.startTime).toLocaleString()}</p>\n        <p><strong>End Time:</strong> {new Date(battle.endTime).toLocaleString()}</p>\n        <p><strong>Participants:</strong> {battle.participantCount}</p>\n        {lastUpdated && <p style={{ fontSize: '14px', color: '#666' }}><strong>Last Updated:</strong> {new Date(lastUpdated).toLocaleString()}</p>}\n      </div>\n\n      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>\n        <h2>Live Leaderboard</h2>\n        {loading && <span style={{ color: '#666', fontSize: '14px' }}>Verifying streams...</span>}\n      </div>\n\n      {leaderboard.length === 0 ? (\n        <p style={{ backgroundColor: 'white', padding: '20px', borderRadius: '5px' }}>No scores yet. Start listening to playlist tracks!</p>\n      ) : (\n        <table style={{ width: '100%', borderCollapse: 'collapse', backgroundColor: 'white' }}>\n          <thead>\n            <tr style={{ backgroundColor: '#333', color: 'white' }}>\n              <th style={{ padding: '10px', textAlign: 'left' }}>Rank</th>\n              <th style={{ padding: '10px', textAlign: 'left' }}>Username</th>\n              <th style={{ padding: '10px', textAlign: 'right' }}>Scrobble Count</th>\n              <th style={{ padding: '10px', textAlign: 'center' }}>Status</th>\n            </tr>\n          </thead>\n          <tbody>\n            {leaderboard.map((entry, index) => (\n              <tr key={entry.userId} style={{ borderBottom: '1px solid #ddd', backgroundColor: entry.isCheater ? '#fff3cd' : 'white' }}>\n                <td style={{ padding: '10px' }}>{index + 1}</td>\n                <td style={{ padding: '10px' }}>\n                  {entry.username}\n                  {entry.isCheater && <span style={{ marginLeft: '5px', color: '#856404', fontSize: '12px' }}>⚠️</span>}\n                </td>\n                <td style={{ padding: '10px', textAlign: 'right' }}>{entry.count}</td>\n                <td style={{ padding: '10px', textAlign: 'center' }}>\n                  {entry.isCheater ? <span style={{ color: '#856404', fontSize: '12px' }}>Flagged</span> : '✓'}\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      )}\n\n      <p style={{ marginTop: '20px', fontSize: '14px', color: '#666' }}>\n        {battle.status === 'active' && '🔴 Leaderboard updates automatically every 30 seconds'}\n        {battle.status === 'ended' && 'Battle has ended. Final results shown.'}\n        {battle.status === 'upcoming' && 'Battle hasn\\'t started yet.'}\n      </p>\n    </div>\n  );\n}\n","size_bytes":6228},"pages/api/user/lastfm.js":{"content":"import connectDB from '../../../utils/db';\nimport User from '../../../models/User';\nimport { createHandler, withCors, withRateLimit, withAuth, withValidation } from '../../../lib/middleware';\nimport { lastfmSchema } from '../../../lib/schemas';\nimport { logger } from '../../../utils/logger';\n\nasync function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    await connectDB();\n\n    const { lastfmUsername } = req.validatedBody;\n\n    const user = await User.findByIdAndUpdate(\n      req.userId,\n      { lastfmUsername },\n      { new: true }\n    );\n\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    logger.info('Last.fm username updated', { userId: user._id, lastfmUsername });\n\n    res.status(200).json({\n      message: 'Last.fm username updated successfully',\n      user: {\n        id: user._id,\n        username: user.username,\n        email: user.email,\n        lastfmUsername: user.lastfmUsername,\n        isAdmin: user.isAdmin,\n      },\n    });\n  } catch (error) {\n    logger.error('Last.fm update error', { error: error.message });\n    res.status(500).json({ error: 'Server error updating Last.fm username' });\n  }\n}\n\nexport default createHandler(handler, [\n  withCors,\n  withRateLimit(10, 60000),\n  withAuth(),\n  withValidation(lastfmSchema),\n]);\n","size_bytes":1381}},"version":2}